function get_source() {
    // lift the meta:source or add it if it doesn't exist

    $name = "validin api"
    [meta:source=($name,) :name=$name]
    return($node)
}


function dns(records) {
    // model DNS records from validin

    // get the meta:source
    $source = $get_source()

    // determine the record type
    for ($type, $type_records) in $records {
        switch $type {
            "A": {$type_func = $a}
            "AAAA": {$type_func = $aaaa}
            // "CAA": {}
            // "CAA_ISSUER_FOR": {}
            // "CAA_ISSUERWILD_FOR": {}
            "CNAME": {$type_func = $cname}
            "CNAME_FOR": {$type_func = $cname_for}
            // "HTTPS": {}
            // "HTTPS_FOR": {}
            "MX": {$type_func = $mx}
            "MX_FOR": {$type_func = $mx_for}
            "NS": {$type_func = $ns}
            "NS_FOR": {$type_func = $ns_for}
            "PTR": {$type_func = $ptr}
            // (
            //    "SOA_MNAME", "SOA_MNAME_FOR", "SOA_RNAME", "SOA_RNAME_FOR"
            // ): {$type_func = $soa}
            // "SRV": {}
            // "SRV_TARGET_FOR": {}
            "TXT": {$type_func = $txt}
            // "WAYWARD_HTTPS": {}
            // "WAYWARD_MX": {}
            // "WAYWARD_NS": {}
            // "WAYWARD_SOA_MNAME": {}
            // "WAYWARD_SOA_RNAME": {}
            // "WAYWARD_TXT": {}
            *: {
                $lib.warn(`Got {$type_records.size()} {$type} record(s), not currently supported`)
                continue
            }
        }

        // model records and edge to meta:source
        yield $type_func($type_records) [<(seen)+ $source]
    }
}


function a(records) {
    // model A records as inet:dns:a

    for $record in $records {
        try {
            if $record.value {  // old format
                if ($record.value_type = "dom") {  // value is the inet:fqdn
                    [inet:dns:a = ($record.value, $record.key)]
                } else {  // value is the inet:ipv4
                    [inet:dns:a = ($record.key, $record.value)]
                }
            } elif $record.name {  // new format
                [inet:dns:a = ($record.name, $record.rdata)]
            } else {  // unknown format
                $lib.warn(`Got an A record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model A record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function aaaa(records) {
    // model AAAA records as inet:dns:aaaa

    for $record in $records {
        try {
            if $record.value {  // old format
                if ($record.value_type = "dom") {  // value is the inet:fqdn
                    [inet:dns:aaaa = ($record.value, $record.key)]
                } else {  // value is the inet:ipv6
                    [inet:dns:aaaa = ($record.key, $record.value)]
                }
            } elif $record.name {  // new format
                [inet:dns:aaaa = ($record.name, $record.rdata)]
            } else {  // unknown format
                $lib.warn(`Got an AAAA record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model AAAA record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function cname(records) {
    // model CNAME records as inet:dns:cname

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:cname = ($record.key, $record.value)]
            } else {  // unknown format
                $lib.warn(`Got a CNAME record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model CNAME record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function cname_for(records) {
    // model CNAME_FOR records as inet:dns:cname

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:cname = ($record.value, $record.key)]
            } else {  // unknown format
                $lib.warn(`Got a CNAME_FOR record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model CNAME_FOR record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function mx(records) {
    // model mx records as inet:dns:mx

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:mx = ($record.key, $record.value)]
            } else {  // unknown format
                $lib.warn(`Got an MX record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model MX record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function mx_for(records) {
    // model MX_FOR records as inet:dns:mx

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:mx = ($record.value, $record.key)]
            } else {  // unknown format
                $lib.warn(`Got an MX_FOR record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model MX_FOR record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function ns(records) {
    // model NS records as inet:dns:ns

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:ns = ($record.key, $record.value)]
            } else {  // unknown format
                $lib.warn(`Got an NS record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model NS record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function ns_for(records) {
    // model NS_FOR records as inet:dns:ns

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:ns = ($record.value, $record.key)]
            } else {  // unknown format
                $lib.warn(`Got an NS_FOR record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model NS_FOR record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function ptr(records) {
    // model PTR records as inet:dns:rev

    for $record in $records {
        try {
            if $record.key {  // old format
                if ($record.value_type = "dom") {
                    [inet:dns:rev = ($record.key, $record.value)]
                } else {
                    [inet:dns:rev = ($record.value, $record.key)]
                }
            } else {  // unknown format
                $lib.warn(`Got a PTR record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model PTR record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function soa(records) {
    // TODO
}


function txt(records) {
    // model TXT records as inet:dns:txt

    for $record in $records {
        try {
            if $record.key {  // old format
                [inet:dns:txt = ($record.key, $record.value)]
            } else {  // unknown format
                $lib.warn(`Got a TXT record in unknown format: {$record}`)
                continue
            }
        } catch * as error {
            $lib.warn(`Failed to model TXT record: {$record}`)
            continue
        }

        // set the .seen property
        $first = ($record.first_seen * 1000)
        $last = ($record.last_seen * 1000)
        $node [.seen=($first, $last)]
    }
}


function whois(records) {
    // model whois records

    $source = $get_source()

    for $record in $records {
        // whois parsing can be partial, need to check for existence of fields

        // use earliest registered time
        try {
            $record.registered.sort()
            $created = $record.registered.index(0)
        } catch * as error {
            $created = $lib.null
        }

        // use latest expires time
        try {
            $record.expires.sort()
            $expires = $record.expires.index(-1)
        } catch * as error {
            $expires = $lib.null
        }

        // use latest updated time
        try {
            $record.changed.sort()
            $updated = $record.changed.index(-1)
        } catch * as error {
            $updated = $lib.null
        }

        try {
            $registrar = $record.registrar.index(0)
        } catch * as error {
            $registrar = $lib.null
        }

        [
            inet:whois:rec=($record.domain, $record.date)
                :created?=$created
                :expires?=$expires
                :registrar?={[inet:whois:rar=$registrar]}
                :updated?=$updated

            // edge to meta:source
            <(seen)+ $source
        ]

        // add nameservers, if available        
        if $record.nameservers {
            {  // isolate for-loop in subquery
                for $nameserver in $record.nameservers {
                    [(inet:whois:recns=($nameserver, $node) <(seen)+ $source)]
                }
            }
        }

        // add contacts, if available
        if $record.roles {
            {  // isolate for-loop in subquery
                for ($role_type, $role) in $record.roles {
                    // email
                    try {
                        $email = $role.email.index(0)
                    } catch * as error {
                        $email = $lib.null
                    }

                    // phone
                    if $role.phone {
                        $phone = $role.phone.index(0)
                    } elif $role.tel {
                        $phone = $role.tel.index(0)

                        if $phone.startswith("tel:") {
                            $phone = $phone.slice(4)
                        }
                    } else {
                        $phone = $lib.null
                    }

                    // fax
                    try {
                        $fax = $role.fax.index(0)
                    } catch * as error {
                        $fax = $lib.null
                    }

                    // name
                    try {
                        $name = $role.name.index(0)
                    } catch * as error {
                        $name = $lib.null
                    }

                    // orgname
                    try {
                        $orgname = $role.org.index(0)
                    } catch * as error {
                        $orgname = $lib.null
                    }

                    // address
                    try {
                        $address = ("\n").join($role.address)
                    } catch * as error {
                        $address = $lib.null
                    }

                    // city 
                    try {
                        $city = $role.city.index(0)
                    } catch * as error {
                        $city = $lib.null
                    }

                    // state
                    try {
                        $state = $role.state.index(0)
                    } catch * as error {
                        $state = $lib.null
                    }

                    // country
                    try {
                        $country = $role.country.index(0)
                    } catch * as error {
                        $country = $lib.null
                    }

                    // url
                    try {
                        $url = $role.url.index(0)
                    } catch * as error {
                        $url = $lib.null
                    }

                    [
                        (
                            inet:whois:contact=($node, $role_type)
                                :address?=$address
                                :city?=$city
                                :country?=$country
                                :email?=$email
                                :fax?=$fax
                                :name?=$name
                                :orgname?=$orgname
                                :phone?=$phone
                                :state?=$state
                                :url?=$url

                            <(seen)+ $source
                        )
                    ]
                }
            }
        }
    }
}

function domain_certificates(records) {
    $source = $get_source()
    for $record in $records {
        $fingerprint = $record.fingerprint
        $subject = `CN={$record.common_name}`
        $notbefore = ($record.not_before * 1000)
        $notafter = ($record.not_after * 1000)

        //parse domains as crypto:x509:sans or inet:fqdn 
        $fqdns = ([])
        $sans = ([])
        for $domain in $record.all_domains {
            // store wildcard domains as sans
            if($domain.startswith('*')){
                $sans.append(('dns', $domain))
            } else {
                $fqdns.append({[inet:fqdn=$domain]})
            }
        }

        // find extra urls
        // TODO: place into extended properties (e.g. :_validin:authority_info_access_uris,..)
        $urls = ()
        $urls.extend($record.authority_info_access_uris)
        $urls.extend($record.certificate_policy_uri)

        // create the cert
        [
            crypto:x509:cert=($fingerprint,)
                :sha1=$fingerprint
                :subject=$subject
                :validity:notbefore=$notbefore
                :validity:notafter=$notafter
                :identities:fqdns?=$fqdns
                :identities:urls?=$urls
                :ext:sans?=$sans

            <(seen)+ $source
        ]
    }
}


function http(records) {
    // model Crawling records from validin

    // get the meta:source
    $source = $get_source()

    $lib.print($lib.len($records))
}