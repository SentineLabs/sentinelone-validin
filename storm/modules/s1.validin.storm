$api = $lib.import(s1.validin.api)
$ingest = $lib.import(s1.validin.ingest)
$ingest_crawlr = $lib.import(s1.validin.ingest.crawlr)
$ingest_ctstream = $lib.import(s1.validin.ingest.ctstream)
$ingest_dns = $lib.import(s1.validin.ingest.dns)
$ingest_pivot = $lib.import(s1.validin.ingest.pivot)
$ingest_registration = $lib.import(s1.validin.ingest.registration)
$ingest_reputation = $lib.import(s1.validin.ingest.reputation)


function dns(fqdn_or_ip, options) {
    // get dns records for an fqdn or ip address

    $form = $fqdn_or_ip.form()

    switch $form {
        "inet:fqdn": {yield $dns_fqdn($fqdn_or_ip.repr(), $options)}
        ("inet:ipv4", "inet:ipv6"): {yield $dns_ip($fqdn_or_ip.repr(), $options)}
        *: {$lib.warn(`{$form} not supported`)}
    }
}


function dns_fqdn(fqdn, options) {
    // get dns records for an fqdn

    $records = ({})

    try {
        $lib.dict.update(
            $records,
            $api.domain_history(
                $fqdn,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                wildcard=$options.wildcard,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }

    try {
        $lib.dict.update(
            $records,
            $api.domain_hostname(
                $fqdn,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                wildcard=$options.wildcard,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }

    try {
        $lib.dict.update(
            $records,
            $api.domain_extra(
                $fqdn,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                wildcard=$options.wildcard,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }

    // model records
    yield $ingest_dns.dns($records)
}


function dns_ip(ip, options) {
    // get dns records for an ip address

    $records = ({})

    try {
        $lib.dict.update(
            $records,
            $api.ip_history(
                $ip,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }

    try {
        $lib.dict.update(
            $records,
            $api.ip_hostname(
                $ip,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }

    /* currently, no data from this endpoint is modeled
    try {
        $lib.dict.update(
            $records,
            $api.ip_extra(
                $ip,
                first_seen=$options.first_seen,
                last_seen=$options.last_seen,
                limit=$options.limit,
            )
        )
    } catch ("HTTPResponseError", "HTTPRetriesExceeded") as error {
        $lib.warn($error)
    }
    */

    // model records
    yield $ingest_dns.dns($records)
}


function whois(inode, options) {
    // get whois records

    $form = $inode.form()

    switch $form {
        "inet:email": {yield $whois_email($inode, $options)}
        "inet:fqdn": {yield $whois_fqdn($inode, $options)}
        *: {$lib.warn(`{$form} not supported`)}
    }

}


function whois_email(email, options) {
    // get whois records for an email

    $records = $api.string_whois(
        $email.repr(),
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        limit=$options.limit
    )

    // model records
    for ($key, $values) in $records {
        yield $ingest_registration.whois($values)
    }
}


function whois_fqdn(fqdn, options) {
    // get whois records for an fqdn

    $records = $api.domain_whois(
        $fqdn.repr(),
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        wildcard=$options.wildcard,
        limit=$options.limit
    )

    // model records
    yield $ingest_registration.whois($records)
}


function certificates(fqdn, options) {
    // get certificates for an fqdn

    $records = $api.domain_certificates(
        $fqdn.repr(),
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        wildcard=$options.wildcard,
        limit=$options.limit
    )

    // model records
    yield $ingest_ctstream.domain_certificates($records)
}


function http(fqdn_or_ip, options) {
    // get dns records for an fqdn or ip address

    $form = $fqdn_or_ip.form()
    $res = $lib.null

    switch $form {
        "inet:fqdn": { $res = $http_fqdn($fqdn_or_ip.repr(), $options)}
        ("inet:ipv4", "inet:ipv6"): { $res = $http_ip($fqdn_or_ip.repr(), $options)}
        *: {$lib.warn(`{$form} not supported`)}
    }

    yield $res
}


function http_fqdn(fqdn, options) {
    // get http records for an fqdn

    $records = $api.domain_crawl_history(
        $fqdn,
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        limit=$options.limit
    )

    // model records
    yield $ingest_crawlr.crawlr($records)
}


function http_ip(ip, options) {
    // get dns records for an ip address

    $records = $api.ip_crawl_history(
        $ip,
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        limit=$options.limit
    )

    // model records
    yield $ingest_crawlr.crawlr($records)
}


function enrich(fqdn_node, options) {
    // enrich an fqdn with dns, crawler, and registration data
    $data = $api.domain_connections(
        $fqdn_node.repr(),
        first_seen=$options.first_seen,
        last_seen=$options.last_seen,
        wildcard=$options.wildcard,
        limit=$options.limit
    )

    // model data
    $res1 = $ingest_dns.dns_v2($data.dns)
    $res2 = $ingest_crawlr.crawlr($data.crawler)
    $res3 = $ingest_registration.whois($data.registration)

    yield ($res1, $res2, $res3) | uniq
}


function pivot(node, options) {
    // Pivot from an inet:http:request or inet:ipv4/6 node via Validin

    $form = $node.form()

    switch $form {
        ("inet:http:request", "hash:sha1","hash:md5", "hash:sha256"): {$pivot_http($node.repr(), $options)}
        *: {$lib.warn(`{$form} not supported`)}
    }
}

function pivot_http(node, options) {
    // Pivot from an inet:http:request node via Validin

    $form = $node.form()

    $hashes = ([])

    if ($form = "inet:http:request") {
        if ($node.props.`_s1:validin:response:favicon:md5` != $lib.null) {
            $hashes.append($node.props.`_s1:validin:response:favicon:md5`)
        }
        if ($node.props.`_s1:validin:response:body:sha1` != $lib.null) {
            $hashes.append($node.props.`_s1:validin:response:body:sha1`)
        }
        if ($node.props.`_s1:validin:response:banner_0:md5` != $lib.null) {
            $hashes.append($node.props.`_s1:validin:response:banner_0:md5`)
        }
        if ($node.props.`_s1:validin:response:class_0:md5` != $lib.null) {
            $hashes.append($node.props.`_s1:validin:response:class_0:md5`)
        }
        if ($node.props.`_s1:validin:response:class_1:md5` != $lib.null) {
            $hashes.append($node.props.`_s1:validin:response:class_1:md5`)
        }
    }

    if ($form = "hash:sha1" or $form = "hash:md5" or $form = "hash:sha256") {
        $hashes.append($node.repr())
    }

    if ($lib.debug or $options.dry_run) {$lib.print(`Hashes: {$hashes}`)}
    if ($lib.debug or $options.dry_run) {$lib.print(`Limit: {$options.limit}`)}

    $all_records = ([])

    for $hash in $hashes {
        $records = $api.hash_pivots(
            $hash,
            category=$options.category,
            first_seen=$options.first_seen,
            last_seen=$options.last_seen,
            limit=$options.limit
        )
        // model records
        if (not $options.dry_run) {
            $records = $ingest_pivot.pivot($records)
            $all_records.extend($records)
        } else {
            $ingest_pivot.pivot_stats($records)
        }
    }

    yield $all_records | uniq
}


function reputation(node, options) {
    // get reputation information for domains and IPs

    $form = $node.form()

    switch $form {
        "inet:fqdn": {yield $reputation_domain($node.repr(), $options)}
        ("inet:ipv4", "inet:ipv6"): {yield $reputation_ip($node.repr(), $options)}
        *: {$lib.warn(`{$form} not supported`)}
    }
}


function reputation_domain(fqdn, options) {
    // get domain reputation

    $data = $api.domain_reputation($fqdn)
    yield $ingest_reputation.domain_reputation($fqdn, $data)
}


function reputation_ip(ip, options) {
    // get IP reputation

    $data = $api.ip_reputation($ip)
    yield $ingest_reputation.ip_reputation($ip, $data)
}
