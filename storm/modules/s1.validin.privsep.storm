function getApiKey() {
    // see if the user has their own key set
    $apikey = $lib.user.vars.get("s1:validin:apikey")
    if ($apikey) {
        return($apikey)
    }

    // no user key, check for global
    $apikey = $lib.globals.get("s1:validin:apikey")
    if ($apikey) {
        return($apikey)
    }
 
    return($lib.false)
}

function setApiKey(key, self) {
    if ($self) {
        $lib.user.vars.set("s1:validin:apikey", $key)
    } else {
        $lib.globals.set("s1:validin:apikey", $key)
    }
    return($checkApiKey())
}


function checkApiKey() {
    $resp = $base_get("ping",{})
        
    if ($resp.status = "OK") {
        return($lib.true)
    } else {
        return($lib.false)
    }
}

function getApiHostname() {
    $hostname = $lib.globals.get("s1:validin:apihostname")
    if ($hostname) {
        return($hostname)
    }
    return("pilot.validin.com")
}

function setApiHostname(hostname) {
    ($ok, $hostname_normalised) = $lib.trycast(inet:fqdn, $hostname)
    if ($ok) {
        $lib.globals.set("s1:validin:apihostname", $hostname)
        return($lib.true)
    } else {
        $lib.warn("Failed to set Validin Api hostname {$hostname}")
        return($lib.false)
    }
    
}

function base_get(uri, params) {
    // base http request for the validin api
    $headers = ({
        "Authorization": `BEARER {$getApiKey()}`,
        "content-type": "application/json",
    })

    $url = `https://{$getApiHostname()}/api/{$uri}`

    // exponential backoff
    $attempts = 5  // max attempts
    $base = 5      // base value

    for $i in $lib.range(($attempts + 1), start=1) {
        // Use the Api key on the callers behalf
        $response = $lib.inet.http.get($url, headers=$headers, params=$params)
        $sleep = ($base ** $i)
        
        if ($response.code = 200) {
            return($response.json())

        } elif ($response.code = -1) {
            // exception occurred, sleep and retry
            $lib.warn(
                `{$url} raised an exception, sleeping {$sleep} seconds and retrying`
            )
            $lib.time.sleep($sleep)

        } elif (500 <= $response.code and $response.code < 600) {
            // server error, sleep and retry
            $lib.warn(
                `{$url} returned HTTP code {$response.code}, sleeping {$sleep} seconds and retrying`
            )
            $lib.time.sleep($sleep)

        } else {
            // client error, raise
            // TODO: inspect the response for an error message
            $msg = `{$url} returned HTTP code {$response.code}`
            $lib.raise("HTTPResponseError", $msg, reason=$response.reason)
        }
    }

    // retries exceeded, raise
    $lib.raise("HTTPRetriesExceeded", `{$url} failed {$attempts} times`)
}
