function get_api_key() {
    // see if the user has their own key set
    $apikey = $lib.user.vars.get("s1:validin:apikey")

    if $apikey {
        return($apikey)
    }

    // no user key, check for global
    $apikey = $lib.globals.get("s1:validin:apikey")

    if $apikey {
        return($apikey)
    }
 
    return($lib.false)
}


function set_api_key(key, global=$lib.false) {
    if $global {
        $admin = $lib.import(s1.validin.privsep.admin)
        $admin.set_global_api_key($key)
    } else {
        $lib.user.vars.set("s1:validin:apikey", $key)
    }

    return($check_api_key())
}


function check_api_key() {
    $resp = $base_get("ping", {})
        
    if ($resp.status = "OK") {
        return($lib.true)
    }

    return($lib.false)
}


function get_api_hostname() {
    $hostname = $lib.globals.get("s1:validin:apihostname")

    if ($hostname) {
        return($hostname)
    }

    return("pilot.validin.com")
}


function base_get(uri, params) {
    // base http request for the validin api

    $headers = ({
        "Authorization": `BEARER {$get_api_key()}`,
        "content-type": "application/json",
    })

    $url = `https://{$get_api_hostname()}/api/{$uri}`

    // exponential backoff
    $attempts = 5  // max attempts
    $base = 5      // base value

    for $i in $lib.range(($attempts + 1), start=1) {
        // Use the Api key on the callers behalf
        $response = $lib.inet.http.get($url, headers=$headers, params=$params)
        $sleep = ($base ** $i)

        if ($response.code = 200) {
            return($response.json())

        } elif ($response.code = -1) {
            // exception occurred, sleep and retry
            $lib.warn(
                `{$url} raised an exception, sleeping {$sleep} seconds and retrying`
            )
            $lib.time.sleep($sleep)

        } elif (500 <= $response.code and $response.code < 600) {
            // server error, sleep and retry
            $lib.warn(
                `{$url} returned HTTP code {$response.code}, sleeping {$sleep} seconds and retrying`
            )
            $lib.time.sleep($sleep)

        } else {
            // client error, raise
            // TODO: inspect the response for an error message
            $msg = `{$url} returned HTTP code {$response.code}`
            $lib.raise("HTTPResponseError", $msg, reason=$response.reason)
        }
    }

    // retries exceeded, raise
    $lib.raise("HTTPRetriesExceeded", `{$url} failed {$attempts} times`)
}
