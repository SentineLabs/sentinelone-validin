$ingest = $lib.import(s1.validin.ingest)

function crawlr(records) {
    // model .crawlr (Crawling Results) records from validin

    $source = $ingest.get_source()

    for $record in $records {
        $key = $record.key
        $first_seen = ($record.first_seen * 1000)
        $last_seen = ($record.last_seen * 1000)

        $value = $record.value

        $time = $value.time
        $parsedTime = $lib.cast(time,$time)

        $ip = $value.ip
        $port = $value.port
        $host = $value.host
        $path = $value.path

        if ($path = $lib.null) {
            $path = '/'
        }

        $scheme= $value.scheme
         if ($scheme = $lib.null) {
            $scheme = 'http'
        }

        //construct URL
        $url = `{$scheme}://{$host}{$path}`
        if ($host = $lib.null) {
            $url = `{$scheme}://{$ip}{$path}`
        }

        //parse banner
        $response_code = $lib.regex.search("^HTTP/\\d\\.\\d\\s+(\\d{3})", $value.banner).index(0)
        $response_reason=  $lib.regex.search("^HTTP/[^\\s]+\\s\\d{3}\\s(.*)", $value.banner_full.index(0)).index(0)

        $headers = ([])
        for $banner_item in  $value.banner_full.slice(1) {
            ($key, $val) = $lib.cast(str, $banner_item).split(":")
            $key = $key.strip()
            $val = $val.strip()
            $headers.append(($key, $val))
        }

        //lift server 
        $server = {
            [ 
                inet:server=`tcp://{$ip}:{$port}` 
                    :ipv4=$ip
                    :port=$port
                    :proto='tcp'

                <(seen)+ $source
            ]
        }

        [
             //unique GUID is derived from Validin scraping strategy
            (inet:http:request=($time, $ip, $scheme, $host, $path)
                :time=$parsedTime
                :server=$server
                :server:ipv4=$ip
                :server:port=$port
                :path=$path
                :url=$url
                :headers=$headers
                :response:code = $response_code
                :response:reason = $response_reason
                :method='GET'
            <(seen)+ $source)
        ]

        if ($value.cert != $lib.null){
            $sans = ([])
            $fqdns = ([])
            for $domain in $value.cert_details.domains {
                if( not $domain.startswith('*')){
                    $fqdns.append({[inet:fqdn=$domain]})
                } 
                $sans.append(('dns', $domain))
            }
            
            [ 
                (
                    crypto:x509:cert=($value.cert_fingerprint_sha256,)
                        :sha256=$value.cert_fingerprint_sha256
                        :sha1=$value.cert_details.fingerprint
                        :issuer=$value.cert.cert_issuer.O
                        :validity:notbefore=$value.cert.not_before
                        :validity:notafter=$value.cert.not_after
                        :identities:fqdns?=$fqdns
                        :ext:sans?=$sans

                )
                 <(seen)+ $source
            ]   
            
            [ 
                (
                    inet:ssl:jarmsample=($server,$value.cert_details.jarm)
                    <(seen)+ $source
                )
            ] 
        }
    }
}