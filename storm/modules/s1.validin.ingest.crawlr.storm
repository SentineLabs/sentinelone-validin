$ingest = $lib.import(s1.validin.ingest)

function crawlr(records) {
    // model .crawlr (Crawling Results) records from validin

    $source = $ingest.get_source()

    for $record in $records {
        $key = $record.key
        $first_seen = ($record.first_seen * 1000)
        $last_seen = ($record.last_seen * 1000)

        $value = $record.value

        $time = $value.time
        $parsedTime = $lib.cast(time,$time)

        $ip = $value.ip
        $port = $value.port
        $host = $value.host
        $path = $value.path

        if ($path = $lib.null) {
            $path = '/'
        }

        $scheme= $value.scheme
         if ($scheme = $lib.null) {
            $scheme = 'http'
        }

        //construct URL

        $url = `{$scheme}://{$host}{$path}`
         if ($host = $lib.null) {
            $url = `{$scheme}://{$ip}{$path}`
        }

        //parse banner
        $response_code = $lib.regex.search("^HTTP/\\d\\.\\d\\s+(\\d{3})", $value.banner).index(0)
        $response_reason=  $lib.regex.search("^HTTP/[^\\s]+\\s\\d{3}\\s(.*)", $value.banner_full.index(0)).index(0)

        $headers = ([])
        for $banner_item in  $value.banner_full.slice(1) {
            ($key, $val) = $lib.cast(str, $banner_item).split(":")
            $key = $key.strip()
            $val = $val.strip()
            $headers.append(($key, $val))
        }

        [
            inet:http:request=($time, $ip, $scheme, $host, $path)
                :time=$parsedTime
                :server:ipv4=$ip
                :server:port=$port
                :url=$url
                :headers=$headers
                :response:code = $response_code
                :response:reason = $response_reason
                :method='GET'
            <(seen)+ $source
        ]
    }
}