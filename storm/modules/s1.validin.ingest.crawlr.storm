$ingest = $lib.import(s1.validin.ingest)


function crawlr(records) {
    // model .crawlr (Crawling Results) records from validin

    $source = $ingest.get_source()

    for $record in $records {
        $value = $record.value
        
        // v2 format (value only)
        if ($record.value = $lib.null) {
            $value = $record
        }

        $time = $value.time
        $parsedTime = $lib.cast(time, $time)

        $ip = $value.ip

        if $value.port {
            $port = $value.port
        } else {
            $port = 80
        }

        if $value.host {
            $host = $value.host
        } else {
            $host = $ip
        }

        $path = $value.path
        if ($path = $lib.null) {
            $path = '/'
        }
        $scheme = $value.scheme
        if ($scheme = $lib.null) {
            $scheme = 'http'
        }
        
        if (($scheme = "http" and $port = 80) or ($scheme = "https" and $port = 443)) {
            $port_urlpart = ""
        } else {
            $port_urlpart = `:{$port}`
        }

        //construct URL
        $url = `{$scheme}://{$host}{$port_urlpart}{$path}`

        //parse banner
        try {
            $response_code = $lib.regex.search("^HTTP/\\d\\.\\d\\s+(\\d{3})", $value.banner).index(0)
        } catch * as error {
            $response_code = $lib.null
        }

        try {
            $response_reason =  $lib.regex.search("^HTTP/[^\\s]+\\s\\d{3}\\s(.*)", $value.banner_full.index(0)).index(0)
        } catch * as error {
            $response_reason = $lib.null
        }

        $headers = ([])

        if $value.banner_full {
            if($value.banner_full.index(0).startswith("HTTP")){
                for $banner_item in $value.banner_full.slice(1) {
                    ($key, $val) = $lib.cast(str, $banner_item).split(":", maxsplit=1)
                    $key = $key.strip()
                    $val = $val.strip()
                    $headers.append(($key, $val))
                }
            }   
            
        }

        //lift server 
        $server = {
            [ 
                inet:server=`tcp://{$ip}:{$port}` 
                    :ipv4=$ip
                    :port=$port
                    :proto='tcp'
            ]
        }

        [
             //unique GUID is derived from Validin scraping strategy
            (
                inet:http:request=($time, $ip, $scheme, $host, $port, $path)
                    :time=$parsedTime
                    :server=$server
                    :server:ipv4=$ip
                    :server:port=$port
                    :path=$path
                    :url=$url
                    :headers=$headers
                    :response:code?=$response_code
                    :response:reason?=$response_reason
                    :method='GET'
                    :_s1:validin:response:body:sha1?=$value.body_hash
                    :_s1:validin:response:favicon:md5?=$value.favicon_hash
                    :_s1:validin:response:banner_0:md5?=$value.banner_0_hash
                    :_s1:validin:response:class_0:md5?=$value.class_0_hash
                    :_s1:validin:response:class_1:md5?=$value.class_1_hash
            )
            <(seen)+ $source
        ]

        if $value.error {
            $lib.warn(`{$node.iden()} {$time} {$ip} {$scheme} {$host} {$port} {$path} {$value.error}`)
        }

        if $value.cert {
            $sans = ([])
            $fqdns = $lib.set()
            $ipv4s = $lib.set()
            $ipv6s = $lib.set()

            for $domain in $value.cert_details.domains {
                if ($lib.trycast("inet:fqdn",$domain).index(0)){
                    if($domain.find(".") != $lib.null){
                        $fqdns.add({[inet:fqdn=$domain]})
                    } else {
                        $sans.append(('other', $domain))
                    }
                } elif ($lib.trycast("inet:ipv4",$domain).index(0)) {
                    $ipv4s.add({[inet:ipv4=$domain]})
                } elif  ($lib.trycast("inet:ipv6",$domain).index(0)) {
                    $ipv6s.add({[inet:ipv6=$domain]})
                } else {
                    if $domain.startswith("*") {
                        $sans.append(('dns', $domain))
                    } else {
                        $sans.append(('other', $domain))
                    }
                } 
            }
            
            $cert = { crypto:x509:cert=($value.cert_fingerprint_sha256,) }


            if ($cert != $lib.null) {
                if ($cert.props.'identities:fqdns') {  $fqdns.adds($cert.props.'identities:fqdns') }
                if ($cert.props.'identities:ipv4s') { $ipv4s.adds($cert.props.'identities:ipv4s') }
                if ($cert.props.'identities:ipv6s') { $ipv6s.adds($cert.props.'identities:ipv6s') }
                if ($cert.props.'identities:sans') { $sans.extend($cert.props.'identities:sans') }
            }

            if ($lib.len($fqdns)) {$fqdns=$fqdns.list()} else { $fqdns = $lib.null }
            if ($lib.len($ipv4s)) {$ipv4s=$ipv4s.list()} else { $ipv4s = $lib.null }
            if ($lib.len($ipv6s)) {$ipv6s=$ipv6s.list()} else { $ipv6s = $lib.null }
            //if ($lib.len($sans))  {$sans=$sans.list()} else { $sans = $lib.null }  // TODO: Dedup ans sort sans array of tuples
            
            {
                [ 
                    (
                        crypto:x509:cert=($value.cert_fingerprint_sha256,)
                            :sha256=$value.cert_fingerprint_sha256
                            :sha1=$value.cert_details.fingerprint
                            :issuer=$value.cert.cert_issuer.O
                            :validity:notbefore=$value.cert.not_before
                            :validity:notafter=$value.cert.not_after
                            :identities:fqdns?=$fqdns
                            :identities:ipv4s?=$ipv4s
                            :identities:ipv6s?=$ipv6s
                            //:ext:sans?=$sans
                    )
                ] 
            }

            if $value.cert_details.jarm {
                {
                    [
                        (
                            inet:ssl:jarmsample=($server, $value.cert_details.jarm)
                        )
                    ]
                }
            }
        }
    }
}
